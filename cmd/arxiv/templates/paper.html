{{define "paper"}}
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="view-transition" content="same-origin">
	<title>{{.Paper.Title}} - arXiv Cache</title>
	<script>
	MathJax = {
		tex: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
	};
	</script>
	<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async></script>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<style>
		/* View Transitions */
		::view-transition-old(root) { animation: fade-out 0.2s ease-out; }
		::view-transition-new(root) { animation: fade-in 0.2s ease-in; }
		@keyframes fade-out { from { opacity: 1; } to { opacity: 0; } }
		@keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }

		/* Hero transition for paper cards expanding into full view */
		::view-transition-old(paper-hero) {
			animation: scale-down 0.3s ease-out;
			transform-origin: center;
		}
		::view-transition-new(paper-hero) {
			animation: scale-up 0.3s ease-out;
			transform-origin: center;
		}
		@keyframes scale-down {
			from { transform: scale(1); opacity: 1; }
			to { transform: scale(0.8); opacity: 0; }
		}
		@keyframes scale-up {
			from { transform: scale(0.8); opacity: 0; }
			to { transform: scale(1); opacity: 1; }
		}

		* { box-sizing: border-box; }
		body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; line-height: 1.6; color: #1e293b; max-width: 960px; margin: 0 auto; padding: 1rem; }
		a { color: #1d4ed8; text-decoration: none; }
		a:hover { text-decoration: underline; }
		h1 { font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem; view-transition-name: paper-hero; }
		h2 { font-size: 1.1rem; font-weight: 600; margin: 1.5rem 0 0.75rem; border-bottom: 1px solid #e2e8f0; padding-bottom: 0.25rem; }

		.nav { margin-bottom: 1.5rem; font-size: 0.875rem; }
		.nav a { margin-right: 1rem; }
		.meta { font-size: 0.875rem; color: #64748b; margin-bottom: 0.5rem; }
		.meta code { font-family: monospace; background: #f1f5f9; padding: 0.1rem 0.3rem; border-radius: 3px; }
		.authors { margin-bottom: 0.5rem; }
		.categories { margin-bottom: 1rem; }
		.cat-link { display: inline-block; font-family: monospace; font-size: 0.8rem; background: #f1f5f9; padding: 0.15rem 0.5rem; border-radius: 3px; margin-right: 0.25rem; margin-bottom: 0.25rem; }
		.abstract { white-space: pre-wrap; color: #334155; margin-bottom: 1rem; }
		.actions { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem; }
		.btn { display: inline-block; padding: 0.4rem 0.75rem; font-size: 0.8rem; background: #1d4ed8; color: #fff; border-radius: 4px; border: none; cursor: pointer; }
		.btn:hover { background: #1e40af; text-decoration: none; }
		.btn-secondary { background: #64748b; }
		.btn-secondary:hover { background: #475569; }
		.links { font-size: 0.875rem; margin-bottom: 1rem; }
		.links a { margin-right: 1rem; }

		/* Citation graph */
		.graph-container { position: relative; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 6px; height: 500px; margin: 1rem 0; }
		.graph-controls { position: absolute; top: 0.5rem; right: 0.5rem; display: flex; gap: 0.5rem; z-index: 10; }
		.graph-btn { padding: 0.3rem 0.6rem; font-size: 0.75rem; background: #fff; border: 1px solid #e2e8f0; border-radius: 4px; cursor: pointer; }
		.graph-btn:hover { background: #f1f5f9; }
		.graph-legend { position: absolute; bottom: 0.5rem; left: 0.5rem; background: #fff; border: 1px solid #e2e8f0; border-radius: 4px; padding: 0.4rem 0.6rem; font-size: 0.7rem; }
		.legend-item { display: flex; align-items: center; gap: 0.4rem; margin: 0.15rem 0; }
		.legend-dot { width: 10px; height: 10px; border-radius: 50%; }
		.graph-tooltip { position: fixed; padding: 0.5rem 0.75rem; background: rgba(0,0,0,0.9); color: #fff; border-radius: 4px; font-size: 0.75rem; max-width: 300px; pointer-events: none; z-index: 100; display: none; }
		.graph-node { cursor: pointer; stroke: #fff; stroke-width: 1.5px; }
		.graph-node:hover { stroke-width: 3px; }
		.graph-node.selected { stroke: #1d4ed8; stroke-width: 3px; }
		.graph-link { stroke: #94a3b8; stroke-opacity: 0.4; fill: none; }
		.graph-link.highlighted { stroke: #1d4ed8; stroke-opacity: 1; stroke-width: 2px; }
		.fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000; height: 100vh; border-radius: 0; }

		/* References list */
		.refs { list-style: none; padding: 0; }
		.refs li { padding: 0.5rem 0.75rem; border-bottom: 1px solid #f1f5f9; font-size: 0.875rem; border-radius: 4px; margin-bottom: 2px; cursor: pointer; transition: background 0.15s, transform 0.1s; }
		.refs li:hover { background: #eff6ff; transform: translateX(2px); }
		.refs li.transitioning { view-transition-name: paper-hero; }
		.ref-id { font-family: monospace; color: #64748b; }
		.ref-title { color: #1e293b; font-weight: 500; }
		.ref-meta { font-size: 0.75rem; color: #94a3b8; }
		.ref-cached { color: #059669; }
		.ref-uncached { color: #94a3b8; font-style: italic; }
		.ref-date { color: #94a3b8; font-size: 0.8rem; }
		.badge { display: inline-block; font-size: 0.65rem; padding: 0.1rem 0.3rem; border-radius: 2px; margin-left: 0.25rem; }
		.badge-src { background: #dcfce7; color: #166534; }
		.badge-ref { background: #dbeafe; color: #1e40af; }
		.badge-citing { background: #fef3c7; color: #92400e; }

		/* Files list */
		.files { list-style: none; padding: 0; }
		.files li { font-family: monospace; font-size: 0.875rem; padding: 0.25rem 0; }

		/* Loading */
		.loading { font-size: 0.8rem; color: #64748b; }
		.loading::before { content: ""; display: inline-block; width: 10px; height: 10px; border: 2px solid #e2e8f0; border-top-color: #1d4ed8; border-radius: 50%; margin-right: 0.4rem; animation: spin 1s linear infinite; vertical-align: middle; }
		@keyframes spin { to { transform: rotate(360deg); } }
	</style>
</head>
<body>
<div class="nav"><a href="/">Home</a> <a href="/categories">Categories</a></div>

<h1>{{.Paper.Title}}</h1>
<div class="meta">
	<code>{{.Paper.ID}}</code> · {{.Paper.Created.Format "2006-01-02"}} · Cited by {{.CitedByCount}}
</div>
<div class="authors">{{range $i, $a := parseAuthors .Paper.Authors}}{{if $i}}, {{end}}<a href="/author/{{$a}}">{{$a}}</a>{{end}}</div>
<div class="categories">{{range $i, $c := parseCategories .Paper.Categories}}<a class="cat-link" href="/category/{{$c}}">{{$c}}</a>{{end}}</div>

<div class="abstract">{{.Paper.Abstract}}</div>

<div class="actions">
	{{if .Paper.PDFDownloaded}}<a class="btn" href="/pdf/{{.Paper.ID}}">View PDF</a>{{else}}<form style="display:inline" method="POST" action="/pdf/{{.Paper.ID}}/fetch"><button class="btn btn-secondary">Fetch PDF</button></form>{{end}}
	<a class="btn btn-secondary" href="{{.Paper.AbstractURL}}" target="_blank" rel="noopener noreferrer">Open on arxiv.org</a>
</div>
{{if .FetchingSource}}<div class="loading" id="source-status">Fetching TeX source and extracting references...</div>{{end}}
<div class="links">
	<a href="{{.Paper.AbstractURL}}">Original on arxiv.org</a>
	<a href="{{.Paper.PDFURL}}">PDF (external)</a>
	{{if .Paper.DOI}}<a href="https://doi.org/{{.Paper.DOI}}">DOI</a>{{end}}
</div>

<h2>Citation Graph</h2>
<div class="graph-container" id="graph-container">
	<div class="graph-controls">
		<button class="graph-btn" id="reset-btn">Reset</button>
		<button class="graph-btn" id="fullscreen-btn">Fullscreen</button>
	</div>
	<div class="graph-legend">
		<div class="legend-item"><div class="legend-dot" style="background:#1d4ed8;"></div> This paper</div>
		<div class="legend-item"><div class="legend-dot" style="background:#334155;"></div> Reference</div>
		<div class="legend-item"><div class="legend-dot" style="background:#10b981;"></div> Citing</div>
		<div class="legend-item"><div class="legend-dot" style="background:#94a3b8;"></div> Uncached</div>
	</div>
</div>
<div class="graph-tooltip" id="tooltip"></div>

{{if .PaperList}}
<h2>References{{if .UncachedCount}} <span class="loading" id="prefetch-status">Loading titles...</span>{{end}}</h2>
<ul class="refs" id="refs-list">
{{range .PaperList}}{{if .IsRef}}
<li data-id="{{.ID}}">
	<span class="ref-id">{{.ID}}</span>
	{{if .Cached}}<a class="ref-title" href="/abs/{{.ID}}">{{.Title}}</a> <span class="ref-date">({{arxivIDToDate .ID}})</span>{{if .Citations}} <span class="ref-meta">{{.Citations}} cites</span>{{end}}
	{{else}}<span class="ref-uncached">{{.ID}}</span> <span class="ref-date">({{arxivIDToDate .ID}})</span> <a href="/paper/{{.ID}}/fetch">[fetch]</a>{{end}}
</li>
{{end}}{{end}}
</ul>

<h2>Cited By</h2>
<ul class="refs" id="citing-list">
{{range .PaperList}}{{if .IsCiting}}
<li data-id="{{.ID}}">
	<span class="ref-id">{{.ID}}</span>
	<a class="ref-title" href="/abs/{{.ID}}">{{.Title}}</a> <span class="ref-date">({{arxivIDToDate .ID}})</span>{{if .Citations}} <span class="ref-meta">{{.Citations}} cites</span>{{end}}
</li>
{{end}}{{end}}
</ul>
{{end}}

{{if .Files}}
<h2>Source Files</h2>
<ul class="files">
{{range .Files}}<li><a href="/src/{{$.Paper.ID}}/{{.}}">{{.}}</a></li>{{end}}
</ul>
{{end}}

<script>
(function() {
	const paperID = "{{.Paper.ID}}";
	const container = document.getElementById('graph-container');
	const tooltip = document.getElementById('tooltip');
	let simulation, svg, g, nodes, links;

	// FLIP-style navigation with View Transitions API
	function navigateWithTransition(element, url) {
		if (!document.startViewTransition) {
			window.location.href = url;
			return;
		}

		// Apply view-transition-name to clicked element
		if (element.tagName === 'circle') {
			// For SVG circles (graph nodes), we need a workaround
			// SVG elements don't support view-transition-name well
			// Fall back to root transition
			document.startViewTransition(() => { window.location.href = url; });
		} else if (element.closest) {
			// For DOM elements like list items
			const li = element.closest('li');
			if (li) {
				li.classList.add('transitioning');
			}
			document.startViewTransition(() => { window.location.href = url; });
		} else {
			document.startViewTransition(() => { window.location.href = url; });
		}
	}

	// Make reference list items clickable
	document.querySelectorAll('.refs li').forEach(li => {
		const id = li.dataset.id;
		if (!id) return;

		// Find if this is cached (has a link) or uncached
		const link = li.querySelector('a.ref-title');
		const fetchLink = li.querySelector('a[href$="/fetch"]');

		li.addEventListener('click', (e) => {
			// Don't intercept if clicking directly on a link
			if (e.target.tagName === 'A') return;

			const url = link ? '/paper/' + id : '/paper/' + id + '/fetch';
			navigateWithTransition(li, url);
		});
	});

	// Paper list for coloring nodes (will be updated dynamically)
	let paperList = [
		{{range .PaperList}}{id:"{{.ID}}",isRef:{{.IsRef}},isCiting:{{.IsCiting}},cached:{{.Cached}}},{{end}}
	];

	let graphInitialized = false;
	let zoom;

	function highlightNode(id, highlight) {
		if (!nodes || !links) return;
		nodes.classed('selected', d => d.id === id && highlight);
		links.classed('highlighted', d => (d.source.id === id || d.target.id === id) && highlight);
	}

	function setupRefListHovers() {
		document.querySelectorAll('.refs li').forEach(el => {
			el.addEventListener('mouseenter', () => highlightNode(el.dataset.id, true));
			el.addEventListener('mouseleave', () => highlightNode(el.dataset.id, false));
		});
	}

	// Initialize reference list hovers
	setupRefListHovers();

	function getNodeColor(d) {
		if (d.id === paperID) return '#1d4ed8';
		if (!d.cached) return '#94a3b8';
		const item = paperList.find(p => p.id === d.id);
		if (item && item.isCiting) return '#10b981';
		return '#334155';
	}

	function refreshGraph() {
		return fetch('/paper/' + paperID + '/graph')
			.then(r => r.json())
			.then(data => {
				if (!data.nodes || data.nodes.length === 0) {
					if (!graphInitialized) {
						container.innerHTML = '<p style="padding:2rem;color:#64748b;text-align:center;">No citation data available.</p>';
					}
					return;
				}

				const width = container.clientWidth;
				const height = container.clientHeight;

				// First time: create SVG and setup
				if (!graphInitialized) {
					// Remove placeholder if present
					const placeholder = container.querySelector('p');
					if (placeholder) placeholder.remove();

					svg = d3.select('#graph-container')
						.append('svg')
						.attr('width', width)
						.attr('height', height);

					g = svg.append('g');

					zoom = d3.zoom()
						.scaleExtent([0.2, 4])
						.on('zoom', e => g.attr('transform', e.transform));
					svg.call(zoom);

					svg.append('defs').append('marker')
						.attr('id', 'arrow')
						.attr('viewBox', '0 -5 10 10')
						.attr('refX', 20)
						.attr('markerWidth', 6)
						.attr('markerHeight', 6)
						.attr('orient', 'auto')
						.append('path')
						.attr('d', 'M0,-5L10,0L0,5')
						.attr('fill', '#94a3b8');

					// Create group elements for links and nodes
					g.append('g').attr('class', 'links-group');
					g.append('g').attr('class', 'nodes-group');

					document.getElementById('reset-btn').addEventListener('click', () => {
						svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
						if (simulation) simulation.alpha(0.3).restart();
					});

					document.getElementById('fullscreen-btn').addEventListener('click', () => {
						container.classList.toggle('fullscreen');
						const btn = document.getElementById('fullscreen-btn');
						btn.textContent = container.classList.contains('fullscreen') ? 'Exit' : 'Fullscreen';
						svg.attr('width', container.clientWidth).attr('height', container.clientHeight);
						if (simulation) {
							simulation.force('center', d3.forceCenter(container.clientWidth / 2, container.clientHeight / 2));
							simulation.alpha(0.3).restart();
						}
					});

					document.addEventListener('keydown', e => {
						if (e.key === 'Escape' && container.classList.contains('fullscreen')) {
							container.classList.remove('fullscreen');
							document.getElementById('fullscreen-btn').textContent = 'Fullscreen';
							svg.attr('width', container.clientWidth).attr('height', container.clientHeight);
							if (simulation) {
								simulation.force('center', d3.forceCenter(container.clientWidth / 2, container.clientHeight / 2));
								simulation.alpha(0.3).restart();
							}
						}
					});

					graphInitialized = true;
				}

				// Update scales based on new data
				const maxCitations = Math.max(1, ...data.nodes.map(n => n.citations));
				const radiusScale = d3.scaleSqrt().domain([0, maxCitations]).range([5, 18]);

				// Stop existing simulation
				if (simulation) simulation.stop();

				// Create new simulation
				simulation = d3.forceSimulation(data.nodes)
					.force('link', d3.forceLink(data.edges).id(d => d.id).distance(80))
					.force('charge', d3.forceManyBody().strength(-250))
					.force('center', d3.forceCenter(width / 2, height / 2))
					.force('collision', d3.forceCollide().radius(d => radiusScale(d.citations) + 4));

				// Update links with D3 data join
				links = g.select('.links-group')
					.selectAll('line')
					.data(data.edges, d => d.source.id ? d.source.id + '->' + d.target.id : d.source + '->' + d.target)
					.join(
						enter => enter.append('line')
							.attr('class', 'graph-link')
							.attr('marker-end', 'url(#arrow)')
							.style('opacity', 0)
							.call(el => el.transition().duration(300).style('opacity', 1)),
						update => update,
						exit => exit.transition().duration(200).style('opacity', 0).remove()
					);

				// Update nodes with D3 data join
				nodes = g.select('.nodes-group')
					.selectAll('circle')
					.data(data.nodes, d => d.id)
					.join(
						enter => enter.append('circle')
							.attr('class', 'graph-node')
							.attr('r', 0)
							.attr('fill', getNodeColor)
							.call(el => el.transition().duration(300).attr('r', d => d.id === paperID ? 12 : radiusScale(d.citations))),
						update => update
							.call(el => el.transition().duration(300)
								.attr('r', d => d.id === paperID ? 12 : radiusScale(d.citations))
								.attr('fill', getNodeColor)),
						exit => exit.transition().duration(200).attr('r', 0).remove()
					);

				// Re-apply drag behavior
				nodes.call(d3.drag()
					.on('start', (e) => { if (!e.active) simulation.alphaTarget(0.3).restart(); e.subject.fx = e.subject.x; e.subject.fy = e.subject.y; })
					.on('drag', (e) => { e.subject.fx = e.x; e.subject.fy = e.y; })
					.on('end', (e) => { if (!e.active) simulation.alphaTarget(0); e.subject.fx = null; e.subject.fy = null; }));

				// Re-apply event handlers
				nodes.on('click', (e, d) => {
					const url = d.cached ? '/paper/' + d.id : '/paper/' + d.id + '/fetch';
					navigateWithTransition(e.target, url);
				});

				nodes.on('mouseover', (e, d) => {
					tooltip.style.display = 'block';
					tooltip.innerHTML = '<strong>' + d.id + '</strong><br>' + d.title + '<br>' + d.year + ' · ' + d.citations + ' citations';
					highlightNode(d.id, true);
					document.querySelectorAll('.refs li[data-id="' + d.id + '"]').forEach(el => el.style.background = '#eff6ff');
				});

				nodes.on('mousemove', e => {
					tooltip.style.left = (e.clientX + 12) + 'px';
					tooltip.style.top = (e.clientY + 12) + 'px';
				});

				nodes.on('mouseout', (e, d) => {
					tooltip.style.display = 'none';
					highlightNode(d.id, false);
					document.querySelectorAll('.refs li[data-id="' + d.id + '"]').forEach(el => el.style.background = '');
				});

				simulation.on('tick', () => {
					links.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
						 .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
					nodes.attr('cx', d => d.x).attr('cy', d => d.y);
				});
			});
	}

	// Refresh references list from server
	function refreshRefsList() {
		return fetch('/paper/' + paperID + '/refs')
			.then(r => r.json())
			.then(refs => {
				// Update paperList for graph coloring
				paperList = refs.map(r => ({
					id: r.id,
					isRef: true,
					isCiting: false,
					cached: r.hasTitle
				}));

				const refsList = document.getElementById('refs-list');
				if (!refsList) return;

				// Clear and rebuild refs list
				refsList.innerHTML = '';
				refs.forEach(r => {
					const li = document.createElement('li');
					li.dataset.id = r.id;
					const dateStr = arxivIDToDate(r.id);
					const datePart = dateStr ? ' <span class="ref-date">(' + dateStr + ')</span>' : '';
					if (r.hasTitle) {
						li.innerHTML = '<span class="ref-id">' + r.id + '</span> <a class="ref-title" href="/paper/' + r.id + '">' + escapeHtml(r.title) + '</a>' + datePart + (r.citedBy ? ' <span class="ref-meta">' + r.citedBy + ' cites</span>' : '');
					} else {
						li.innerHTML = '<span class="ref-id">' + r.id + '</span> <span class="ref-uncached">' + r.id + '</span>' + datePart + ' <a href="/paper/' + r.id + '/fetch">[fetch]</a>';
					}
					refsList.appendChild(li);
				});

				// Re-setup click handlers and hovers
				setupRefListHovers();
				setupRefListClicks();

				// Re-render any math in titles
				if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
					MathJax.typesetPromise();
				}
			});
	}

	function escapeHtml(s) {
		const div = document.createElement('div');
		div.textContent = s;
		return div.innerHTML;
	}

	// Parse arXiv ID to date string (e.g., "2302.13971" -> "Feb 2023")
	function arxivIDToDate(id) {
		const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
		let yymm = '';
		// Old format: category/YYMMNNN
		const slashIdx = id.indexOf('/');
		if (slashIdx >= 0) {
			const num = id.substring(slashIdx + 1);
			if (num.length >= 4) yymm = num.substring(0, 4);
		} else {
			// New format: YYMM.NNNNN
			const dotIdx = id.indexOf('.');
			if (dotIdx === 4) yymm = id.substring(0, 4);
		}
		if (yymm.length !== 4) return '';
		const yy = parseInt(yymm.substring(0, 2), 10);
		const mm = parseInt(yymm.substring(2, 4), 10);
		if (isNaN(yy) || isNaN(mm) || mm < 1 || mm > 12) return '';
		const year = yy >= 91 ? 1900 + yy : 2000 + yy;
		return months[mm - 1] + ' ' + year;
	}

	function setupRefListClicks() {
		document.querySelectorAll('.refs li').forEach(li => {
			const id = li.dataset.id;
			if (!id) return;
			li.addEventListener('click', (e) => {
				if (e.target.tagName === 'A') return;
				const link = li.querySelector('a.ref-title');
				const url = link ? '/paper/' + id : '/paper/' + id + '/fetch';
				navigateWithTransition(li, url);
			});
		});
	}

	// Initial graph load
	refreshGraph();

	// Prefetch reference titles and update the list
	// Shows loading indicator, calls prefetch endpoint, then refreshes refs list
	function prefetchAndRefresh() {
		// Show loading indicator
		const refsHeader = document.querySelector('h2');
		let status = document.getElementById('prefetch-status');
		if (!status && refsHeader && refsHeader.textContent.includes('References')) {
			status = document.createElement('span');
			status.id = 'prefetch-status';
			status.className = 'loading';
			status.textContent = ' Loading titles...';
			refsHeader.appendChild(status);
		}

		// Call prefetch (synchronous - waits for all titles)
		return fetch('/paper/' + paperID + '/prefetch-refs', { method: 'POST' })
			.then(r => r.json())
			.then(() => {
				// Prefetch done - refresh the refs list to show titles
				return refreshRefsList();
			})
			.then(() => {
				refreshGraph();
				const s = document.getElementById('prefetch-status');
				if (s) s.remove();
			})
			.catch(err => {
				console.error('Prefetch error:', err);
				const s = document.getElementById('prefetch-status');
				if (s) s.remove();
			});
	}

	{{if .UncachedCount}}
	// Prefetch titles for uncached refs on page load
	prefetchAndRefresh();
	{{end}}

	{{if .FetchingSource}}
	// Poll for source download completion
	const sourcePoller = setInterval(() => {
		fetch('/paper/' + paperID + '/status')
			.then(r => r.json())
			.then(status => {
				if (status.sourceDownloaded) {
					clearInterval(sourcePoller);
					// Remove the source loading indicator
					const sourceStatus = document.getElementById('source-status');
					if (sourceStatus) sourceStatus.remove();

					// Refresh refs list to show extracted citations, then prefetch titles
					refreshRefsList().then(() => {
						refreshGraph();
						// Now prefetch titles for the newly extracted references
						prefetchAndRefresh();
					});
				}
			});
	}, 2000);
	{{end}}
})();
</script>
</body>
</html>
{{end}}
